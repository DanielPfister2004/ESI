/*
 * hal_usciB1.c
 *
 *  Created on: 03.11.2025
 *      Author: danie
 */
#include <msp430.h>
#include "hal_gpio.h"
#include "hal_usciB1.h"

USCIB1_SPICom LCD;

void init_GPIO_SPI()
{
    P8SEL |= (LCD_MISO | LCD_MOSI | LCD_CLK);
    P8DIR |= (LCD_MOSI | LCD_CLK);
    P8DIR &= ~LCD_MISO;
    //P8DIR |= LCD_CS;     // Richtung: Ausgang
    P8OUT |= BIT1;     // Initialzustand: HIGH (CS deaktiviert)
}

void hal_USCIB1Init()
{   // register B is for LCD
    UCB1CTL1 |= UCSWRST;    // activating wurstbit

    UCB1CTL0 &= ~UCCKPH;    // phase
    UCB1CTL0 |= UCCKPL;     // polarity
    UCB1CTL0 |= UCMSB;      // MSB first
    UCB1CTL0 &= ~UC7BIT;    // 8bit length
    UCB1CTL0 |= UCMST;      // master mode
    UCB1CTL0 |= UCMODE0;    // 3pin mode
    UCB1CTL0 |= UCSYNC;     // sync
    UCB1CTL1 |= UCSSEL__SMCLK;     // master clock

    UCB1BR0 = FREQ / 2500000;
    UCB1BR1 = 0;

    UCB1CTL1 &= ~UCSWRST;   // deactivating wurstbit

    UCB1IE |= UCTXIE;        // receive interrupt
}

void hal_USCIB1Transmit()
{
    CS_LOW;
    LCD.Status.TxSuc = 0;
    LCD.TxData.cnt = 0;
    while (UCB1STAT & UCBUSY)
        ;   // waits till receive or transmit is finished

    if (LCD.TxData.cnt < LCD.TxData.len)
    {
        UCB1TXBUF = LCD.TxData.Data[LCD.TxData.cnt];
        LCD.TxData.cnt++;
    }
    LCD.Status.TxSuc = 0;
    CS_HIGH;
}

#pragma vector=USCI_B1_VECTOR
__interrupt void USCI_B1_ISR(void)
{
    if (UCB1IFG & UCRXIFG)
    {
        LCD.RxData.Data[LCD.TxData.cnt++] = UCB1RXBUF;     // clears interrupt bit

        LCD.RxData.len++;

//        if (LCD.TxData.cnt <= LCD.TxData.len)
//        {
//            LCD.Status.TxSuc = 0;
//            UCB1TXBUF = LCD.TxData.Data[LCD.TxData.cnt];
//        }
//        else
//        {
//            LCD.Status.TxSuc = 1;
//            // Chip Select deaktivieren (HIGH)
//            CS_HIGH;
//        }

    }
    //UCA1IFG &= ~UCRXIFG;
}

